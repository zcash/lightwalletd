// Copyright (c) 2019-2021 The Zcash developers
// Distributed under the MIT software license, see the accompanying
// file COPYING or https://www.opensource.org/licenses/mit-license.php .

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        v6.33.2
// source: compact_formats.proto

package walletrpc

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Information about the state of the chain as of a given block.
type ChainMetadata struct {
	state                     protoimpl.MessageState `protogen:"open.v1"`
	SaplingCommitmentTreeSize uint32                 `protobuf:"varint,1,opt,name=saplingCommitmentTreeSize,proto3" json:"saplingCommitmentTreeSize,omitempty"` // the size of the Sapling note commitment tree as of the end of this block
	OrchardCommitmentTreeSize uint32                 `protobuf:"varint,2,opt,name=orchardCommitmentTreeSize,proto3" json:"orchardCommitmentTreeSize,omitempty"` // the size of the Orchard note commitment tree as of the end of this block
	unknownFields             protoimpl.UnknownFields
	sizeCache                 protoimpl.SizeCache
}

func (x *ChainMetadata) Reset() {
	*x = ChainMetadata{}
	mi := &file_compact_formats_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ChainMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChainMetadata) ProtoMessage() {}

func (x *ChainMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_compact_formats_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChainMetadata.ProtoReflect.Descriptor instead.
func (*ChainMetadata) Descriptor() ([]byte, []int) {
	return file_compact_formats_proto_rawDescGZIP(), []int{0}
}

func (x *ChainMetadata) GetSaplingCommitmentTreeSize() uint32 {
	if x != nil {
		return x.SaplingCommitmentTreeSize
	}
	return 0
}

func (x *ChainMetadata) GetOrchardCommitmentTreeSize() uint32 {
	if x != nil {
		return x.OrchardCommitmentTreeSize
	}
	return 0
}

// A compact representation of a Zcash block.
//
// CompactBlock is a packaging of ONLY the data from a block that's needed to:
//  1. Detect a payment to your Shielded address
//  2. Detect a spend of your Shielded notes
//  3. Update your witnesses to generate new spend proofs.
//  4. Spend UTXOs associated to t-addresses of your wallet.
type CompactBlock struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ProtoVersion  uint32                 `protobuf:"varint,1,opt,name=protoVersion,proto3" json:"protoVersion,omitempty"`  // the version of this wire format, for storage
	Height        uint64                 `protobuf:"varint,2,opt,name=height,proto3" json:"height,omitempty"`              // the height of this block
	Hash          []byte                 `protobuf:"bytes,3,opt,name=hash,proto3" json:"hash,omitempty"`                   // the ID (hash) of this block, same as in block explorers
	PrevHash      []byte                 `protobuf:"bytes,4,opt,name=prevHash,proto3" json:"prevHash,omitempty"`           // the ID (hash) of this block's predecessor
	Time          uint32                 `protobuf:"varint,5,opt,name=time,proto3" json:"time,omitempty"`                  // Unix epoch time when the block was mined
	Header        []byte                 `protobuf:"bytes,6,opt,name=header,proto3" json:"header,omitempty"`               // full header (as returned by the getblock RPC)
	Vtx           []*CompactTx           `protobuf:"bytes,7,rep,name=vtx,proto3" json:"vtx,omitempty"`                     // zero or more compact transactions from this block
	ChainMetadata *ChainMetadata         `protobuf:"bytes,8,opt,name=chainMetadata,proto3" json:"chainMetadata,omitempty"` // information about the state of the chain as of this block
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CompactBlock) Reset() {
	*x = CompactBlock{}
	mi := &file_compact_formats_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CompactBlock) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CompactBlock) ProtoMessage() {}

func (x *CompactBlock) ProtoReflect() protoreflect.Message {
	mi := &file_compact_formats_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CompactBlock.ProtoReflect.Descriptor instead.
func (*CompactBlock) Descriptor() ([]byte, []int) {
	return file_compact_formats_proto_rawDescGZIP(), []int{1}
}

func (x *CompactBlock) GetProtoVersion() uint32 {
	if x != nil {
		return x.ProtoVersion
	}
	return 0
}

func (x *CompactBlock) GetHeight() uint64 {
	if x != nil {
		return x.Height
	}
	return 0
}

func (x *CompactBlock) GetHash() []byte {
	if x != nil {
		return x.Hash
	}
	return nil
}

func (x *CompactBlock) GetPrevHash() []byte {
	if x != nil {
		return x.PrevHash
	}
	return nil
}

func (x *CompactBlock) GetTime() uint32 {
	if x != nil {
		return x.Time
	}
	return 0
}

func (x *CompactBlock) GetHeader() []byte {
	if x != nil {
		return x.Header
	}
	return nil
}

func (x *CompactBlock) GetVtx() []*CompactTx {
	if x != nil {
		return x.Vtx
	}
	return nil
}

func (x *CompactBlock) GetChainMetadata() *ChainMetadata {
	if x != nil {
		return x.ChainMetadata
	}
	return nil
}

// A compact representation of a Zcash transaction.
//
// CompactTx contains the minimum information for a wallet to know if this transaction
// is relevant to it (either pays to it or spends from it) via shielded elements. Additionally,
// it can optionally include the minimum necessary data to detect payments to transparent addresses
// related to your wallet.
type CompactTx struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The index of the transaction within the block.
	Index uint64 `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	// The id of the transaction as defined in
	// [§ 7.1.1 ‘Transaction Identifiers’](https://zips.z.cash/protocol/protocol.pdf#txnidentifiers)
	// This byte array MUST be in protocol order and MUST NOT be reversed
	// or hex-encoded; the byte-reversed and hex-encoded representation is
	// exclusively a textual representation of a txid.
	Txid []byte `protobuf:"bytes,2,opt,name=txid,proto3" json:"txid,omitempty"`
	// The transaction fee: present if server can provide. In the case of a
	// stateless server and a transaction with transparent inputs, this will be
	// unset because the calculation requires reference to prior transactions.
	// If there are no transparent inputs, the fee will be calculable as:
	//
	//	valueBalanceSapling + valueBalanceOrchard + sum(vPubNew) - sum(vPubOld) - sum(tOut)
	Fee     uint32                  `protobuf:"varint,3,opt,name=fee,proto3" json:"fee,omitempty"`
	Spends  []*CompactSaplingSpend  `protobuf:"bytes,4,rep,name=spends,proto3" json:"spends,omitempty"`
	Outputs []*CompactSaplingOutput `protobuf:"bytes,5,rep,name=outputs,proto3" json:"outputs,omitempty"`
	Actions []*CompactOrchardAction `protobuf:"bytes,6,rep,name=actions,proto3" json:"actions,omitempty"`
	// `CompactTxIn` values corresponding to the `vin` entries of the full transaction.
	//
	// Note: the single null-outpoint input for coinbase transactions is omitted. Light
	// clients can test `CompactTx.index == 0` to determine whether a `CompactTx`
	// represents a coinbase transaction, as the coinbase transaction is always the
	// first transaction in any block.
	Vin []*CompactTxIn `protobuf:"bytes,7,rep,name=vin,proto3" json:"vin,omitempty"`
	// A sequence of transparent outputs being created by the transaction.
	Vout          []*TxOut `protobuf:"bytes,8,rep,name=vout,proto3" json:"vout,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CompactTx) Reset() {
	*x = CompactTx{}
	mi := &file_compact_formats_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CompactTx) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CompactTx) ProtoMessage() {}

func (x *CompactTx) ProtoReflect() protoreflect.Message {
	mi := &file_compact_formats_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CompactTx.ProtoReflect.Descriptor instead.
func (*CompactTx) Descriptor() ([]byte, []int) {
	return file_compact_formats_proto_rawDescGZIP(), []int{2}
}

func (x *CompactTx) GetIndex() uint64 {
	if x != nil {
		return x.Index
	}
	return 0
}

func (x *CompactTx) GetTxid() []byte {
	if x != nil {
		return x.Txid
	}
	return nil
}

func (x *CompactTx) GetFee() uint32 {
	if x != nil {
		return x.Fee
	}
	return 0
}

func (x *CompactTx) GetSpends() []*CompactSaplingSpend {
	if x != nil {
		return x.Spends
	}
	return nil
}

func (x *CompactTx) GetOutputs() []*CompactSaplingOutput {
	if x != nil {
		return x.Outputs
	}
	return nil
}

func (x *CompactTx) GetActions() []*CompactOrchardAction {
	if x != nil {
		return x.Actions
	}
	return nil
}

func (x *CompactTx) GetVin() []*CompactTxIn {
	if x != nil {
		return x.Vin
	}
	return nil
}

func (x *CompactTx) GetVout() []*TxOut {
	if x != nil {
		return x.Vout
	}
	return nil
}

// A compact representation of a transparent transaction input.
type CompactTxIn struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The id of the transaction that generated the output being spent. This
	// byte array must be in protocol order and MUST NOT be reversed or
	// hex-encoded.
	PrevoutTxid []byte `protobuf:"bytes,1,opt,name=prevoutTxid,proto3" json:"prevoutTxid,omitempty"`
	// The index of the output being spent in the `vout` array of the
	// transaction referred to by `prevoutTxid`.
	PrevoutIndex  uint32 `protobuf:"varint,2,opt,name=prevoutIndex,proto3" json:"prevoutIndex,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CompactTxIn) Reset() {
	*x = CompactTxIn{}
	mi := &file_compact_formats_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CompactTxIn) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CompactTxIn) ProtoMessage() {}

func (x *CompactTxIn) ProtoReflect() protoreflect.Message {
	mi := &file_compact_formats_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CompactTxIn.ProtoReflect.Descriptor instead.
func (*CompactTxIn) Descriptor() ([]byte, []int) {
	return file_compact_formats_proto_rawDescGZIP(), []int{3}
}

func (x *CompactTxIn) GetPrevoutTxid() []byte {
	if x != nil {
		return x.PrevoutTxid
	}
	return nil
}

func (x *CompactTxIn) GetPrevoutIndex() uint32 {
	if x != nil {
		return x.PrevoutIndex
	}
	return 0
}

// A transparent output being created by the transaction.
//
// This contains identical data to the `TxOut` type in the transaction itself, and
// thus it is not "compact".
type TxOut struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The value of the output, in Zatoshis.
	Value uint64 `protobuf:"varint,1,opt,name=value,proto3" json:"value,omitempty"`
	// The script pubkey that must be satisfied in order to spend this output.
	ScriptPubKey  []byte `protobuf:"bytes,2,opt,name=scriptPubKey,proto3" json:"scriptPubKey,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TxOut) Reset() {
	*x = TxOut{}
	mi := &file_compact_formats_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TxOut) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TxOut) ProtoMessage() {}

func (x *TxOut) ProtoReflect() protoreflect.Message {
	mi := &file_compact_formats_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TxOut.ProtoReflect.Descriptor instead.
func (*TxOut) Descriptor() ([]byte, []int) {
	return file_compact_formats_proto_rawDescGZIP(), []int{4}
}

func (x *TxOut) GetValue() uint64 {
	if x != nil {
		return x.Value
	}
	return 0
}

func (x *TxOut) GetScriptPubKey() []byte {
	if x != nil {
		return x.ScriptPubKey
	}
	return nil
}

// A compact representation of a [Sapling Spend](https://zips.z.cash/protocol/protocol.pdf#spendencodingandconsensus).
//
// CompactSaplingSpend is a Sapling Spend Description as described in 7.3 of the Zcash
// protocol specification.
type CompactSaplingSpend struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Nf            []byte                 `protobuf:"bytes,1,opt,name=nf,proto3" json:"nf,omitempty"` // Nullifier (see the Zcash protocol specification)
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CompactSaplingSpend) Reset() {
	*x = CompactSaplingSpend{}
	mi := &file_compact_formats_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CompactSaplingSpend) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CompactSaplingSpend) ProtoMessage() {}

func (x *CompactSaplingSpend) ProtoReflect() protoreflect.Message {
	mi := &file_compact_formats_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CompactSaplingSpend.ProtoReflect.Descriptor instead.
func (*CompactSaplingSpend) Descriptor() ([]byte, []int) {
	return file_compact_formats_proto_rawDescGZIP(), []int{5}
}

func (x *CompactSaplingSpend) GetNf() []byte {
	if x != nil {
		return x.Nf
	}
	return nil
}

// A compact representation of a [Sapling Output](https://zips.z.cash/protocol/protocol.pdf#outputencodingandconsensus).
//
// It encodes the `cmu` field, `ephemeralKey` field, and a 52-byte prefix of the
// `encCiphertext` field of a Sapling Output Description. Total size is 116 bytes.
type CompactSaplingOutput struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Cmu           []byte                 `protobuf:"bytes,1,opt,name=cmu,proto3" json:"cmu,omitempty"`                   // Note commitment u-coordinate.
	EphemeralKey  []byte                 `protobuf:"bytes,2,opt,name=ephemeralKey,proto3" json:"ephemeralKey,omitempty"` // Ephemeral public key.
	Ciphertext    []byte                 `protobuf:"bytes,3,opt,name=ciphertext,proto3" json:"ciphertext,omitempty"`     // First 52 bytes of ciphertext.
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CompactSaplingOutput) Reset() {
	*x = CompactSaplingOutput{}
	mi := &file_compact_formats_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CompactSaplingOutput) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CompactSaplingOutput) ProtoMessage() {}

func (x *CompactSaplingOutput) ProtoReflect() protoreflect.Message {
	mi := &file_compact_formats_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CompactSaplingOutput.ProtoReflect.Descriptor instead.
func (*CompactSaplingOutput) Descriptor() ([]byte, []int) {
	return file_compact_formats_proto_rawDescGZIP(), []int{6}
}

func (x *CompactSaplingOutput) GetCmu() []byte {
	if x != nil {
		return x.Cmu
	}
	return nil
}

func (x *CompactSaplingOutput) GetEphemeralKey() []byte {
	if x != nil {
		return x.EphemeralKey
	}
	return nil
}

func (x *CompactSaplingOutput) GetCiphertext() []byte {
	if x != nil {
		return x.Ciphertext
	}
	return nil
}

// A compact representation of an [Orchard Action](https://zips.z.cash/protocol/protocol.pdf#actionencodingandconsensus).
type CompactOrchardAction struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Nullifier     []byte                 `protobuf:"bytes,1,opt,name=nullifier,proto3" json:"nullifier,omitempty"`       // [32] The nullifier of the input note
	Cmx           []byte                 `protobuf:"bytes,2,opt,name=cmx,proto3" json:"cmx,omitempty"`                   // [32] The x-coordinate of the note commitment for the output note
	EphemeralKey  []byte                 `protobuf:"bytes,3,opt,name=ephemeralKey,proto3" json:"ephemeralKey,omitempty"` // [32] An encoding of an ephemeral Pallas public key
	Ciphertext    []byte                 `protobuf:"bytes,4,opt,name=ciphertext,proto3" json:"ciphertext,omitempty"`     // [52] The first 52 bytes of the encCiphertext field
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CompactOrchardAction) Reset() {
	*x = CompactOrchardAction{}
	mi := &file_compact_formats_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CompactOrchardAction) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CompactOrchardAction) ProtoMessage() {}

func (x *CompactOrchardAction) ProtoReflect() protoreflect.Message {
	mi := &file_compact_formats_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CompactOrchardAction.ProtoReflect.Descriptor instead.
func (*CompactOrchardAction) Descriptor() ([]byte, []int) {
	return file_compact_formats_proto_rawDescGZIP(), []int{7}
}

func (x *CompactOrchardAction) GetNullifier() []byte {
	if x != nil {
		return x.Nullifier
	}
	return nil
}

func (x *CompactOrchardAction) GetCmx() []byte {
	if x != nil {
		return x.Cmx
	}
	return nil
}

func (x *CompactOrchardAction) GetEphemeralKey() []byte {
	if x != nil {
		return x.EphemeralKey
	}
	return nil
}

func (x *CompactOrchardAction) GetCiphertext() []byte {
	if x != nil {
		return x.Ciphertext
	}
	return nil
}

var File_compact_formats_proto protoreflect.FileDescriptor

const file_compact_formats_proto_rawDesc = "" +
	"\n" +
	"\x15compact_formats.proto\x12\x15cash.z.wallet.sdk.rpc\"\x8b\x01\n" +
	"\rChainMetadata\x12<\n" +
	"\x19saplingCommitmentTreeSize\x18\x01 \x01(\rR\x19saplingCommitmentTreeSize\x12<\n" +
	"\x19orchardCommitmentTreeSize\x18\x02 \x01(\rR\x19orchardCommitmentTreeSize\"\xa6\x02\n" +
	"\fCompactBlock\x12\"\n" +
	"\fprotoVersion\x18\x01 \x01(\rR\fprotoVersion\x12\x16\n" +
	"\x06height\x18\x02 \x01(\x04R\x06height\x12\x12\n" +
	"\x04hash\x18\x03 \x01(\fR\x04hash\x12\x1a\n" +
	"\bprevHash\x18\x04 \x01(\fR\bprevHash\x12\x12\n" +
	"\x04time\x18\x05 \x01(\rR\x04time\x12\x16\n" +
	"\x06header\x18\x06 \x01(\fR\x06header\x122\n" +
	"\x03vtx\x18\a \x03(\v2 .cash.z.wallet.sdk.rpc.CompactTxR\x03vtx\x12J\n" +
	"\rchainMetadata\x18\b \x01(\v2$.cash.z.wallet.sdk.rpc.ChainMetadataR\rchainMetadata\"\x81\x03\n" +
	"\tCompactTx\x12\x14\n" +
	"\x05index\x18\x01 \x01(\x04R\x05index\x12\x12\n" +
	"\x04txid\x18\x02 \x01(\fR\x04txid\x12\x10\n" +
	"\x03fee\x18\x03 \x01(\rR\x03fee\x12B\n" +
	"\x06spends\x18\x04 \x03(\v2*.cash.z.wallet.sdk.rpc.CompactSaplingSpendR\x06spends\x12E\n" +
	"\aoutputs\x18\x05 \x03(\v2+.cash.z.wallet.sdk.rpc.CompactSaplingOutputR\aoutputs\x12E\n" +
	"\aactions\x18\x06 \x03(\v2+.cash.z.wallet.sdk.rpc.CompactOrchardActionR\aactions\x124\n" +
	"\x03vin\x18\a \x03(\v2\".cash.z.wallet.sdk.rpc.CompactTxInR\x03vin\x120\n" +
	"\x04vout\x18\b \x03(\v2\x1c.cash.z.wallet.sdk.rpc.TxOutR\x04vout\"S\n" +
	"\vCompactTxIn\x12 \n" +
	"\vprevoutTxid\x18\x01 \x01(\fR\vprevoutTxid\x12\"\n" +
	"\fprevoutIndex\x18\x02 \x01(\rR\fprevoutIndex\"A\n" +
	"\x05TxOut\x12\x14\n" +
	"\x05value\x18\x01 \x01(\x04R\x05value\x12\"\n" +
	"\fscriptPubKey\x18\x02 \x01(\fR\fscriptPubKey\"%\n" +
	"\x13CompactSaplingSpend\x12\x0e\n" +
	"\x02nf\x18\x01 \x01(\fR\x02nf\"l\n" +
	"\x14CompactSaplingOutput\x12\x10\n" +
	"\x03cmu\x18\x01 \x01(\fR\x03cmu\x12\"\n" +
	"\fephemeralKey\x18\x02 \x01(\fR\fephemeralKey\x12\x1e\n" +
	"\n" +
	"ciphertext\x18\x03 \x01(\fR\n" +
	"ciphertext\"\x8a\x01\n" +
	"\x14CompactOrchardAction\x12\x1c\n" +
	"\tnullifier\x18\x01 \x01(\fR\tnullifier\x12\x10\n" +
	"\x03cmx\x18\x02 \x01(\fR\x03cmx\x12\"\n" +
	"\fephemeralKey\x18\x03 \x01(\fR\fephemeralKey\x12\x1e\n" +
	"\n" +
	"ciphertext\x18\x04 \x01(\fR\n" +
	"ciphertextB\x1bZ\x16lightwalletd/walletrpc\xba\x02\x00b\x06proto3"

var (
	file_compact_formats_proto_rawDescOnce sync.Once
	file_compact_formats_proto_rawDescData []byte
)

func file_compact_formats_proto_rawDescGZIP() []byte {
	file_compact_formats_proto_rawDescOnce.Do(func() {
		file_compact_formats_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_compact_formats_proto_rawDesc), len(file_compact_formats_proto_rawDesc)))
	})
	return file_compact_formats_proto_rawDescData
}

var file_compact_formats_proto_msgTypes = make([]protoimpl.MessageInfo, 8)
var file_compact_formats_proto_goTypes = []any{
	(*ChainMetadata)(nil),        // 0: cash.z.wallet.sdk.rpc.ChainMetadata
	(*CompactBlock)(nil),         // 1: cash.z.wallet.sdk.rpc.CompactBlock
	(*CompactTx)(nil),            // 2: cash.z.wallet.sdk.rpc.CompactTx
	(*CompactTxIn)(nil),          // 3: cash.z.wallet.sdk.rpc.CompactTxIn
	(*TxOut)(nil),                // 4: cash.z.wallet.sdk.rpc.TxOut
	(*CompactSaplingSpend)(nil),  // 5: cash.z.wallet.sdk.rpc.CompactSaplingSpend
	(*CompactSaplingOutput)(nil), // 6: cash.z.wallet.sdk.rpc.CompactSaplingOutput
	(*CompactOrchardAction)(nil), // 7: cash.z.wallet.sdk.rpc.CompactOrchardAction
}
var file_compact_formats_proto_depIdxs = []int32{
	2, // 0: cash.z.wallet.sdk.rpc.CompactBlock.vtx:type_name -> cash.z.wallet.sdk.rpc.CompactTx
	0, // 1: cash.z.wallet.sdk.rpc.CompactBlock.chainMetadata:type_name -> cash.z.wallet.sdk.rpc.ChainMetadata
	5, // 2: cash.z.wallet.sdk.rpc.CompactTx.spends:type_name -> cash.z.wallet.sdk.rpc.CompactSaplingSpend
	6, // 3: cash.z.wallet.sdk.rpc.CompactTx.outputs:type_name -> cash.z.wallet.sdk.rpc.CompactSaplingOutput
	7, // 4: cash.z.wallet.sdk.rpc.CompactTx.actions:type_name -> cash.z.wallet.sdk.rpc.CompactOrchardAction
	3, // 5: cash.z.wallet.sdk.rpc.CompactTx.vin:type_name -> cash.z.wallet.sdk.rpc.CompactTxIn
	4, // 6: cash.z.wallet.sdk.rpc.CompactTx.vout:type_name -> cash.z.wallet.sdk.rpc.TxOut
	7, // [7:7] is the sub-list for method output_type
	7, // [7:7] is the sub-list for method input_type
	7, // [7:7] is the sub-list for extension type_name
	7, // [7:7] is the sub-list for extension extendee
	0, // [0:7] is the sub-list for field type_name
}

func init() { file_compact_formats_proto_init() }
func file_compact_formats_proto_init() {
	if File_compact_formats_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_compact_formats_proto_rawDesc), len(file_compact_formats_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   8,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_compact_formats_proto_goTypes,
		DependencyIndexes: file_compact_formats_proto_depIdxs,
		MessageInfos:      file_compact_formats_proto_msgTypes,
	}.Build()
	File_compact_formats_proto = out.File
	file_compact_formats_proto_goTypes = nil
	file_compact_formats_proto_depIdxs = nil
}
