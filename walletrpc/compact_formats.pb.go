// Copyright (c) 2019-2021 The Zcash developers
// Distributed under the MIT software license, see the accompanying
// file COPYING or https://www.opensource.org/licenses/mit-license.php .

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.9
// 	protoc        v6.32.0
// source: compact_formats.proto

package walletrpc

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// ChainMetadata represents information about the state of the chain as of a given block.
type ChainMetadata struct {
	state                     protoimpl.MessageState `protogen:"open.v1"`
	SaplingCommitmentTreeSize uint32                 `protobuf:"varint,1,opt,name=saplingCommitmentTreeSize,proto3" json:"saplingCommitmentTreeSize,omitempty"` // the size of the Sapling note commitment tree as of the end of this block
	OrchardCommitmentTreeSize uint32                 `protobuf:"varint,2,opt,name=orchardCommitmentTreeSize,proto3" json:"orchardCommitmentTreeSize,omitempty"` // the size of the Orchard note commitment tree as of the end of this block
	unknownFields             protoimpl.UnknownFields
	sizeCache                 protoimpl.SizeCache
}

func (x *ChainMetadata) Reset() {
	*x = ChainMetadata{}
	mi := &file_compact_formats_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ChainMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChainMetadata) ProtoMessage() {}

func (x *ChainMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_compact_formats_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChainMetadata.ProtoReflect.Descriptor instead.
func (*ChainMetadata) Descriptor() ([]byte, []int) {
	return file_compact_formats_proto_rawDescGZIP(), []int{0}
}

func (x *ChainMetadata) GetSaplingCommitmentTreeSize() uint32 {
	if x != nil {
		return x.SaplingCommitmentTreeSize
	}
	return 0
}

func (x *ChainMetadata) GetOrchardCommitmentTreeSize() uint32 {
	if x != nil {
		return x.OrchardCommitmentTreeSize
	}
	return 0
}

// CompactBlock is a packaging of ONLY the data from a block that's needed to:
//  1. Detect a payment to your shielded Sapling address
//  2. Detect a spend of your shielded Sapling notes
//  3. Update your witnesses to generate new Sapling spend proofs.
type CompactBlock struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ProtoVersion  uint32                 `protobuf:"varint,1,opt,name=protoVersion,proto3" json:"protoVersion,omitempty"`  // the version of this wire format, for storage
	Height        uint64                 `protobuf:"varint,2,opt,name=height,proto3" json:"height,omitempty"`              // the height of this block
	Hash          []byte                 `protobuf:"bytes,3,opt,name=hash,proto3" json:"hash,omitempty"`                   // the ID (hash) of this block, same as in block explorers
	PrevHash      []byte                 `protobuf:"bytes,4,opt,name=prevHash,proto3" json:"prevHash,omitempty"`           // the ID (hash) of this block's predecessor
	Time          uint32                 `protobuf:"varint,5,opt,name=time,proto3" json:"time,omitempty"`                  // Unix epoch time when the block was mined
	Header        []byte                 `protobuf:"bytes,6,opt,name=header,proto3" json:"header,omitempty"`               // (hash, prevHash, and time) OR (full header)
	Vtx           []*CompactTx           `protobuf:"bytes,7,rep,name=vtx,proto3" json:"vtx,omitempty"`                     // zero or more compact transactions from this block
	ChainMetadata *ChainMetadata         `protobuf:"bytes,8,opt,name=chainMetadata,proto3" json:"chainMetadata,omitempty"` // information about the state of the chain as of this block
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CompactBlock) Reset() {
	*x = CompactBlock{}
	mi := &file_compact_formats_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CompactBlock) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CompactBlock) ProtoMessage() {}

func (x *CompactBlock) ProtoReflect() protoreflect.Message {
	mi := &file_compact_formats_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CompactBlock.ProtoReflect.Descriptor instead.
func (*CompactBlock) Descriptor() ([]byte, []int) {
	return file_compact_formats_proto_rawDescGZIP(), []int{1}
}

func (x *CompactBlock) GetProtoVersion() uint32 {
	if x != nil {
		return x.ProtoVersion
	}
	return 0
}

func (x *CompactBlock) GetHeight() uint64 {
	if x != nil {
		return x.Height
	}
	return 0
}

func (x *CompactBlock) GetHash() []byte {
	if x != nil {
		return x.Hash
	}
	return nil
}

func (x *CompactBlock) GetPrevHash() []byte {
	if x != nil {
		return x.PrevHash
	}
	return nil
}

func (x *CompactBlock) GetTime() uint32 {
	if x != nil {
		return x.Time
	}
	return 0
}

func (x *CompactBlock) GetHeader() []byte {
	if x != nil {
		return x.Header
	}
	return nil
}

func (x *CompactBlock) GetVtx() []*CompactTx {
	if x != nil {
		return x.Vtx
	}
	return nil
}

func (x *CompactBlock) GetChainMetadata() *ChainMetadata {
	if x != nil {
		return x.ChainMetadata
	}
	return nil
}

// CompactTx contains the minimum information for a wallet to know if this transaction
// is relevant to it (either pays to it or spends from it) via shielded elements
// only. This message will not encode a transparent-to-transparent transaction.
type CompactTx struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Index and hash will allow the receiver to call out to chain
	// explorers or other data structures to retrieve more information
	// about this transaction.
	Index uint64 `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"` // the index within the full block
	Hash  []byte `protobuf:"bytes,2,opt,name=hash,proto3" json:"hash,omitempty"`    // the ID (hash) of this transaction, same as in block explorers
	// The transaction fee: present if server can provide. In the case of a
	// stateless server and a transaction with transparent inputs, this will be
	// unset because the calculation requires reference to prior transactions.
	// If there are no transparent inputs, the fee will be calculable as:
	//
	//	valueBalanceSapling + valueBalanceOrchard + sum(vPubNew) - sum(vPubOld) - sum(tOut)
	Fee           uint32                  `protobuf:"varint,3,opt,name=fee,proto3" json:"fee,omitempty"`
	Spends        []*CompactSaplingSpend  `protobuf:"bytes,4,rep,name=spends,proto3" json:"spends,omitempty"`
	Outputs       []*CompactSaplingOutput `protobuf:"bytes,5,rep,name=outputs,proto3" json:"outputs,omitempty"`
	Actions       []*CompactOrchardAction `protobuf:"bytes,6,rep,name=actions,proto3" json:"actions,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CompactTx) Reset() {
	*x = CompactTx{}
	mi := &file_compact_formats_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CompactTx) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CompactTx) ProtoMessage() {}

func (x *CompactTx) ProtoReflect() protoreflect.Message {
	mi := &file_compact_formats_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CompactTx.ProtoReflect.Descriptor instead.
func (*CompactTx) Descriptor() ([]byte, []int) {
	return file_compact_formats_proto_rawDescGZIP(), []int{2}
}

func (x *CompactTx) GetIndex() uint64 {
	if x != nil {
		return x.Index
	}
	return 0
}

func (x *CompactTx) GetHash() []byte {
	if x != nil {
		return x.Hash
	}
	return nil
}

func (x *CompactTx) GetFee() uint32 {
	if x != nil {
		return x.Fee
	}
	return 0
}

func (x *CompactTx) GetSpends() []*CompactSaplingSpend {
	if x != nil {
		return x.Spends
	}
	return nil
}

func (x *CompactTx) GetOutputs() []*CompactSaplingOutput {
	if x != nil {
		return x.Outputs
	}
	return nil
}

func (x *CompactTx) GetActions() []*CompactOrchardAction {
	if x != nil {
		return x.Actions
	}
	return nil
}

// CompactSaplingSpend is a Sapling Spend Description as described in 7.3 of the Zcash
// protocol specification.
type CompactSaplingSpend struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Nf            []byte                 `protobuf:"bytes,1,opt,name=nf,proto3" json:"nf,omitempty"` // nullifier (see the Zcash protocol specification)
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CompactSaplingSpend) Reset() {
	*x = CompactSaplingSpend{}
	mi := &file_compact_formats_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CompactSaplingSpend) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CompactSaplingSpend) ProtoMessage() {}

func (x *CompactSaplingSpend) ProtoReflect() protoreflect.Message {
	mi := &file_compact_formats_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CompactSaplingSpend.ProtoReflect.Descriptor instead.
func (*CompactSaplingSpend) Descriptor() ([]byte, []int) {
	return file_compact_formats_proto_rawDescGZIP(), []int{3}
}

func (x *CompactSaplingSpend) GetNf() []byte {
	if x != nil {
		return x.Nf
	}
	return nil
}

// output encodes the `cmu` field, `ephemeralKey` field, and a 52-byte prefix of the
// `encCiphertext` field of a Sapling Output Description. These fields are described in
// section 7.4 of the Zcash protocol spec:
// https://zips.z.cash/protocol/protocol.pdf#outputencodingandconsensus
// Total size is 116 bytes.
type CompactSaplingOutput struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Cmu           []byte                 `protobuf:"bytes,1,opt,name=cmu,proto3" json:"cmu,omitempty"`                   // note commitment u-coordinate
	EphemeralKey  []byte                 `protobuf:"bytes,2,opt,name=ephemeralKey,proto3" json:"ephemeralKey,omitempty"` // ephemeral public key
	Ciphertext    []byte                 `protobuf:"bytes,3,opt,name=ciphertext,proto3" json:"ciphertext,omitempty"`     // first 52 bytes of ciphertext
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CompactSaplingOutput) Reset() {
	*x = CompactSaplingOutput{}
	mi := &file_compact_formats_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CompactSaplingOutput) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CompactSaplingOutput) ProtoMessage() {}

func (x *CompactSaplingOutput) ProtoReflect() protoreflect.Message {
	mi := &file_compact_formats_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CompactSaplingOutput.ProtoReflect.Descriptor instead.
func (*CompactSaplingOutput) Descriptor() ([]byte, []int) {
	return file_compact_formats_proto_rawDescGZIP(), []int{4}
}

func (x *CompactSaplingOutput) GetCmu() []byte {
	if x != nil {
		return x.Cmu
	}
	return nil
}

func (x *CompactSaplingOutput) GetEphemeralKey() []byte {
	if x != nil {
		return x.EphemeralKey
	}
	return nil
}

func (x *CompactSaplingOutput) GetCiphertext() []byte {
	if x != nil {
		return x.Ciphertext
	}
	return nil
}

// https://github.com/zcash/zips/blob/main/zip-0225.rst#orchard-action-description-orchardaction
// (but not all fields are needed)
type CompactOrchardAction struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Nullifier     []byte                 `protobuf:"bytes,1,opt,name=nullifier,proto3" json:"nullifier,omitempty"`       // [32] The nullifier of the input note
	Cmx           []byte                 `protobuf:"bytes,2,opt,name=cmx,proto3" json:"cmx,omitempty"`                   // [32] The x-coordinate of the note commitment for the output note
	EphemeralKey  []byte                 `protobuf:"bytes,3,opt,name=ephemeralKey,proto3" json:"ephemeralKey,omitempty"` // [32] An encoding of an ephemeral Pallas public key
	Ciphertext    []byte                 `protobuf:"bytes,4,opt,name=ciphertext,proto3" json:"ciphertext,omitempty"`     // [52] The first 52 bytes of the encCiphertext field
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CompactOrchardAction) Reset() {
	*x = CompactOrchardAction{}
	mi := &file_compact_formats_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CompactOrchardAction) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CompactOrchardAction) ProtoMessage() {}

func (x *CompactOrchardAction) ProtoReflect() protoreflect.Message {
	mi := &file_compact_formats_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CompactOrchardAction.ProtoReflect.Descriptor instead.
func (*CompactOrchardAction) Descriptor() ([]byte, []int) {
	return file_compact_formats_proto_rawDescGZIP(), []int{5}
}

func (x *CompactOrchardAction) GetNullifier() []byte {
	if x != nil {
		return x.Nullifier
	}
	return nil
}

func (x *CompactOrchardAction) GetCmx() []byte {
	if x != nil {
		return x.Cmx
	}
	return nil
}

func (x *CompactOrchardAction) GetEphemeralKey() []byte {
	if x != nil {
		return x.EphemeralKey
	}
	return nil
}

func (x *CompactOrchardAction) GetCiphertext() []byte {
	if x != nil {
		return x.Ciphertext
	}
	return nil
}

var File_compact_formats_proto protoreflect.FileDescriptor

const file_compact_formats_proto_rawDesc = "" +
	"\n" +
	"\x15compact_formats.proto\x12\x15cash.z.wallet.sdk.rpc\"\x8b\x01\n" +
	"\rChainMetadata\x12<\n" +
	"\x19saplingCommitmentTreeSize\x18\x01 \x01(\rR\x19saplingCommitmentTreeSize\x12<\n" +
	"\x19orchardCommitmentTreeSize\x18\x02 \x01(\rR\x19orchardCommitmentTreeSize\"\xa6\x02\n" +
	"\fCompactBlock\x12\"\n" +
	"\fprotoVersion\x18\x01 \x01(\rR\fprotoVersion\x12\x16\n" +
	"\x06height\x18\x02 \x01(\x04R\x06height\x12\x12\n" +
	"\x04hash\x18\x03 \x01(\fR\x04hash\x12\x1a\n" +
	"\bprevHash\x18\x04 \x01(\fR\bprevHash\x12\x12\n" +
	"\x04time\x18\x05 \x01(\rR\x04time\x12\x16\n" +
	"\x06header\x18\x06 \x01(\fR\x06header\x122\n" +
	"\x03vtx\x18\a \x03(\v2 .cash.z.wallet.sdk.rpc.CompactTxR\x03vtx\x12J\n" +
	"\rchainMetadata\x18\b \x01(\v2$.cash.z.wallet.sdk.rpc.ChainMetadataR\rchainMetadata\"\x99\x02\n" +
	"\tCompactTx\x12\x14\n" +
	"\x05index\x18\x01 \x01(\x04R\x05index\x12\x12\n" +
	"\x04hash\x18\x02 \x01(\fR\x04hash\x12\x10\n" +
	"\x03fee\x18\x03 \x01(\rR\x03fee\x12B\n" +
	"\x06spends\x18\x04 \x03(\v2*.cash.z.wallet.sdk.rpc.CompactSaplingSpendR\x06spends\x12E\n" +
	"\aoutputs\x18\x05 \x03(\v2+.cash.z.wallet.sdk.rpc.CompactSaplingOutputR\aoutputs\x12E\n" +
	"\aactions\x18\x06 \x03(\v2+.cash.z.wallet.sdk.rpc.CompactOrchardActionR\aactions\"%\n" +
	"\x13CompactSaplingSpend\x12\x0e\n" +
	"\x02nf\x18\x01 \x01(\fR\x02nf\"l\n" +
	"\x14CompactSaplingOutput\x12\x10\n" +
	"\x03cmu\x18\x01 \x01(\fR\x03cmu\x12\"\n" +
	"\fephemeralKey\x18\x02 \x01(\fR\fephemeralKey\x12\x1e\n" +
	"\n" +
	"ciphertext\x18\x03 \x01(\fR\n" +
	"ciphertext\"\x8a\x01\n" +
	"\x14CompactOrchardAction\x12\x1c\n" +
	"\tnullifier\x18\x01 \x01(\fR\tnullifier\x12\x10\n" +
	"\x03cmx\x18\x02 \x01(\fR\x03cmx\x12\"\n" +
	"\fephemeralKey\x18\x03 \x01(\fR\fephemeralKey\x12\x1e\n" +
	"\n" +
	"ciphertext\x18\x04 \x01(\fR\n" +
	"ciphertextB\x1bZ\x16lightwalletd/walletrpc\xba\x02\x00b\x06proto3"

var (
	file_compact_formats_proto_rawDescOnce sync.Once
	file_compact_formats_proto_rawDescData []byte
)

func file_compact_formats_proto_rawDescGZIP() []byte {
	file_compact_formats_proto_rawDescOnce.Do(func() {
		file_compact_formats_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_compact_formats_proto_rawDesc), len(file_compact_formats_proto_rawDesc)))
	})
	return file_compact_formats_proto_rawDescData
}

var file_compact_formats_proto_msgTypes = make([]protoimpl.MessageInfo, 6)
var file_compact_formats_proto_goTypes = []any{
	(*ChainMetadata)(nil),        // 0: cash.z.wallet.sdk.rpc.ChainMetadata
	(*CompactBlock)(nil),         // 1: cash.z.wallet.sdk.rpc.CompactBlock
	(*CompactTx)(nil),            // 2: cash.z.wallet.sdk.rpc.CompactTx
	(*CompactSaplingSpend)(nil),  // 3: cash.z.wallet.sdk.rpc.CompactSaplingSpend
	(*CompactSaplingOutput)(nil), // 4: cash.z.wallet.sdk.rpc.CompactSaplingOutput
	(*CompactOrchardAction)(nil), // 5: cash.z.wallet.sdk.rpc.CompactOrchardAction
}
var file_compact_formats_proto_depIdxs = []int32{
	2, // 0: cash.z.wallet.sdk.rpc.CompactBlock.vtx:type_name -> cash.z.wallet.sdk.rpc.CompactTx
	0, // 1: cash.z.wallet.sdk.rpc.CompactBlock.chainMetadata:type_name -> cash.z.wallet.sdk.rpc.ChainMetadata
	3, // 2: cash.z.wallet.sdk.rpc.CompactTx.spends:type_name -> cash.z.wallet.sdk.rpc.CompactSaplingSpend
	4, // 3: cash.z.wallet.sdk.rpc.CompactTx.outputs:type_name -> cash.z.wallet.sdk.rpc.CompactSaplingOutput
	5, // 4: cash.z.wallet.sdk.rpc.CompactTx.actions:type_name -> cash.z.wallet.sdk.rpc.CompactOrchardAction
	5, // [5:5] is the sub-list for method output_type
	5, // [5:5] is the sub-list for method input_type
	5, // [5:5] is the sub-list for extension type_name
	5, // [5:5] is the sub-list for extension extendee
	0, // [0:5] is the sub-list for field type_name
}

func init() { file_compact_formats_proto_init() }
func file_compact_formats_proto_init() {
	if File_compact_formats_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_compact_formats_proto_rawDesc), len(file_compact_formats_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   6,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_compact_formats_proto_goTypes,
		DependencyIndexes: file_compact_formats_proto_depIdxs,
		MessageInfos:      file_compact_formats_proto_msgTypes,
	}.Build()
	File_compact_formats_proto = out.File
	file_compact_formats_proto_goTypes = nil
	file_compact_formats_proto_depIdxs = nil
}
